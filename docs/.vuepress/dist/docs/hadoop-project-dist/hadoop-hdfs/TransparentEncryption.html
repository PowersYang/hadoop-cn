<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Transparent Encryption in HDFS | Hadoop中文网</title>
    <meta name="description" content="Hadoop官方文档中文社区">
    <link rel="icon" href="/hadoop.jpeg">
    
    <link rel="preload" href="/assets/css/0.styles.299736e7.css" as="style"><link rel="preload" href="/assets/js/app.44e5c4e8.js" as="script"><link rel="preload" href="/assets/js/2.fd33e103.js" as="script"><link rel="preload" href="/assets/js/82.1f34b986.js" as="script"><link rel="prefetch" href="/assets/js/10.0dbc29ee.js"><link rel="prefetch" href="/assets/js/100.51e7458e.js"><link rel="prefetch" href="/assets/js/101.cab336f3.js"><link rel="prefetch" href="/assets/js/102.d7e40b1a.js"><link rel="prefetch" href="/assets/js/103.3cd23502.js"><link rel="prefetch" href="/assets/js/104.a263cbd3.js"><link rel="prefetch" href="/assets/js/105.1cf856b7.js"><link rel="prefetch" href="/assets/js/106.1bd66c2f.js"><link rel="prefetch" href="/assets/js/107.7acc52af.js"><link rel="prefetch" href="/assets/js/108.096bf626.js"><link rel="prefetch" href="/assets/js/109.91d5ec0d.js"><link rel="prefetch" href="/assets/js/11.84130fe4.js"><link rel="prefetch" href="/assets/js/110.602bc28b.js"><link rel="prefetch" href="/assets/js/111.531e373d.js"><link rel="prefetch" href="/assets/js/112.dcdb6f77.js"><link rel="prefetch" href="/assets/js/113.7519fa7c.js"><link rel="prefetch" href="/assets/js/114.97ce2cfb.js"><link rel="prefetch" href="/assets/js/115.719819cf.js"><link rel="prefetch" href="/assets/js/116.606be43b.js"><link rel="prefetch" href="/assets/js/117.5f1db751.js"><link rel="prefetch" href="/assets/js/118.4c8b3331.js"><link rel="prefetch" href="/assets/js/119.756df93e.js"><link rel="prefetch" href="/assets/js/12.a85df2ad.js"><link rel="prefetch" href="/assets/js/120.9735cc8b.js"><link rel="prefetch" href="/assets/js/121.de0f88c2.js"><link rel="prefetch" href="/assets/js/122.68c84b42.js"><link rel="prefetch" href="/assets/js/123.26f2d157.js"><link rel="prefetch" href="/assets/js/124.b8bb5eac.js"><link rel="prefetch" href="/assets/js/125.d3748b6f.js"><link rel="prefetch" href="/assets/js/126.74a59909.js"><link rel="prefetch" href="/assets/js/127.e75ea051.js"><link rel="prefetch" href="/assets/js/128.86691d41.js"><link rel="prefetch" href="/assets/js/129.1b73844b.js"><link rel="prefetch" href="/assets/js/13.5cc92b07.js"><link rel="prefetch" href="/assets/js/14.23af424b.js"><link rel="prefetch" href="/assets/js/15.d44d7e96.js"><link rel="prefetch" href="/assets/js/16.9433ad8d.js"><link rel="prefetch" href="/assets/js/17.e88b2671.js"><link rel="prefetch" href="/assets/js/18.621a61a9.js"><link rel="prefetch" href="/assets/js/19.c2269943.js"><link rel="prefetch" href="/assets/js/20.97a13073.js"><link rel="prefetch" href="/assets/js/21.cfddb2e0.js"><link rel="prefetch" href="/assets/js/22.3fc2e173.js"><link rel="prefetch" href="/assets/js/23.b44f9aaa.js"><link rel="prefetch" href="/assets/js/24.5118c903.js"><link rel="prefetch" href="/assets/js/25.d075e5d7.js"><link rel="prefetch" href="/assets/js/26.773f2460.js"><link rel="prefetch" href="/assets/js/27.d0e0d308.js"><link rel="prefetch" href="/assets/js/28.bba4c1c3.js"><link rel="prefetch" href="/assets/js/29.0d309c43.js"><link rel="prefetch" href="/assets/js/3.df8ab865.js"><link rel="prefetch" href="/assets/js/30.dc22d7ad.js"><link rel="prefetch" href="/assets/js/31.f4f5b282.js"><link rel="prefetch" href="/assets/js/32.126829f0.js"><link rel="prefetch" href="/assets/js/33.b7210392.js"><link rel="prefetch" href="/assets/js/34.808d7f11.js"><link rel="prefetch" href="/assets/js/35.92cc0670.js"><link rel="prefetch" href="/assets/js/36.525eca62.js"><link rel="prefetch" href="/assets/js/37.085ca99e.js"><link rel="prefetch" href="/assets/js/38.bd6ba530.js"><link rel="prefetch" href="/assets/js/39.bdcf0246.js"><link rel="prefetch" href="/assets/js/4.03a382ed.js"><link rel="prefetch" href="/assets/js/40.0a881a26.js"><link rel="prefetch" href="/assets/js/41.e2d38f86.js"><link rel="prefetch" href="/assets/js/42.d3be59ab.js"><link rel="prefetch" href="/assets/js/43.861403a7.js"><link rel="prefetch" href="/assets/js/44.64ea788c.js"><link rel="prefetch" href="/assets/js/45.586e01c2.js"><link rel="prefetch" href="/assets/js/46.4e18b7fe.js"><link rel="prefetch" href="/assets/js/47.c1dba008.js"><link rel="prefetch" href="/assets/js/48.da57593b.js"><link rel="prefetch" href="/assets/js/49.8e699822.js"><link rel="prefetch" href="/assets/js/5.21b79be3.js"><link rel="prefetch" href="/assets/js/50.697ac881.js"><link rel="prefetch" href="/assets/js/51.6c32c16e.js"><link rel="prefetch" href="/assets/js/52.d137da31.js"><link rel="prefetch" href="/assets/js/53.22caaa9a.js"><link rel="prefetch" href="/assets/js/54.7f1d1532.js"><link rel="prefetch" href="/assets/js/55.40dbbf5b.js"><link rel="prefetch" href="/assets/js/56.04c24edc.js"><link rel="prefetch" href="/assets/js/57.b15918db.js"><link rel="prefetch" href="/assets/js/58.b3eb784b.js"><link rel="prefetch" href="/assets/js/59.0d462dd8.js"><link rel="prefetch" href="/assets/js/6.a2711138.js"><link rel="prefetch" href="/assets/js/60.ae65015b.js"><link rel="prefetch" href="/assets/js/61.9b15da8f.js"><link rel="prefetch" href="/assets/js/62.ca728b66.js"><link rel="prefetch" href="/assets/js/63.312b3bdd.js"><link rel="prefetch" href="/assets/js/64.56be4886.js"><link rel="prefetch" href="/assets/js/65.dff3c3a3.js"><link rel="prefetch" href="/assets/js/66.95dfff51.js"><link rel="prefetch" href="/assets/js/67.17e7a9be.js"><link rel="prefetch" href="/assets/js/68.e3b5c05a.js"><link rel="prefetch" href="/assets/js/69.9ab8c7f8.js"><link rel="prefetch" href="/assets/js/7.e9473145.js"><link rel="prefetch" href="/assets/js/70.8d72690b.js"><link rel="prefetch" href="/assets/js/71.3c25cf04.js"><link rel="prefetch" href="/assets/js/72.02b02d8d.js"><link rel="prefetch" href="/assets/js/73.2a8d2681.js"><link rel="prefetch" href="/assets/js/74.c577aba5.js"><link rel="prefetch" href="/assets/js/75.7d2617b0.js"><link rel="prefetch" href="/assets/js/76.97ad371e.js"><link rel="prefetch" href="/assets/js/77.4495b015.js"><link rel="prefetch" href="/assets/js/78.c7510b35.js"><link rel="prefetch" href="/assets/js/79.dc2b4ca2.js"><link rel="prefetch" href="/assets/js/8.fc1e2b26.js"><link rel="prefetch" href="/assets/js/80.454a982e.js"><link rel="prefetch" href="/assets/js/81.eba66eb5.js"><link rel="prefetch" href="/assets/js/83.a15e7917.js"><link rel="prefetch" href="/assets/js/84.212c8551.js"><link rel="prefetch" href="/assets/js/85.c077f397.js"><link rel="prefetch" href="/assets/js/86.70192242.js"><link rel="prefetch" href="/assets/js/87.e53f7254.js"><link rel="prefetch" href="/assets/js/88.d2f28869.js"><link rel="prefetch" href="/assets/js/89.9b4c13ce.js"><link rel="prefetch" href="/assets/js/9.a7fc3cc9.js"><link rel="prefetch" href="/assets/js/90.af82565a.js"><link rel="prefetch" href="/assets/js/91.153dc863.js"><link rel="prefetch" href="/assets/js/92.ea32e690.js"><link rel="prefetch" href="/assets/js/93.4c656124.js"><link rel="prefetch" href="/assets/js/94.b2283b24.js"><link rel="prefetch" href="/assets/js/95.4ad17bba.js"><link rel="prefetch" href="/assets/js/96.4c0c4821.js"><link rel="prefetch" href="/assets/js/97.14f25834.js"><link rel="prefetch" href="/assets/js/98.92c9fd2d.js"><link rel="prefetch" href="/assets/js/99.ef340791.js">
    <link rel="stylesheet" href="/assets/css/0.styles.299736e7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Hadoop中文网</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="https://hadoop.apache.org/releases.html" target="_blank" rel="noopener noreferrer" class="nav-link external">
  下载安装
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="/docs/" class="nav-link router-link-active">参考文档</a></div><div class="nav-item"><a href="/docs/awesome/" class="nav-link">资源教程</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="语言支持" class="dropdown-title"><span class="title">语言支持</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/language/ch.html" class="nav-link">简体中文</a></li><li class="dropdown-item"><!----> <a href="/language/en.html" class="nav-link">English</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="https://hadoop.apache.org/releases.html" target="_blank" rel="noopener noreferrer" class="nav-link external">
  下载安装
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="/docs/" class="nav-link router-link-active">参考文档</a></div><div class="nav-item"><a href="/docs/awesome/" class="nav-link">资源教程</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="语言支持" class="dropdown-title"><span class="title">语言支持</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/language/ch.html" class="nav-link">简体中文</a></li><li class="dropdown-item"><!----> <a href="/language/en.html" class="nav-link">English</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Transparent Encryption in HDFS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#overview" class="sidebar-link">Overview</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#background" class="sidebar-link">Background</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#use-cases" class="sidebar-link">Use Cases</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#architecture" class="sidebar-link">Architecture</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#overview-2" class="sidebar-link">Overview</a></li><li class="sidebar-sub-header"><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#accessing-data-within-an-encryption-zone" class="sidebar-link">Accessing data within an encryption zone</a></li><li class="sidebar-sub-header"><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#key-management-server-keyprovider-edeks" class="sidebar-link">Key Management Server, KeyProvider, EDEKs</a></li></ul></li><li><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#configuration" class="sidebar-link">Configuration</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#configuring-the-cluster-keyprovider" class="sidebar-link">Configuring the cluster KeyProvider</a></li><li class="sidebar-sub-header"><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#selecting-an-encryption-algorithm-and-codec" class="sidebar-link">Selecting an encryption algorithm and codec</a></li><li class="sidebar-sub-header"><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#namenode-configuration" class="sidebar-link">Namenode configuration</a></li></ul></li><li><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#crypto-command-line-interface" class="sidebar-link">crypto command-line interface</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#createzone" class="sidebar-link">createZone</a></li><li class="sidebar-sub-header"><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#listzones" class="sidebar-link">listZones</a></li><li class="sidebar-sub-header"><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#provisiontrash" class="sidebar-link">provisionTrash</a></li><li class="sidebar-sub-header"><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#getfileencryptioninfo" class="sidebar-link">getFileEncryptionInfo</a></li><li class="sidebar-sub-header"><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#reencryptzone" class="sidebar-link">reencryptZone</a></li><li class="sidebar-sub-header"><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#listreencryptionstatus" class="sidebar-link">listReencryptionStatus</a></li></ul></li><li><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#example-usage" class="sidebar-link">Example usage</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#distcp-considerations" class="sidebar-link">Distcp considerations</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#running-as-the-superuser" class="sidebar-link">Running as the superuser</a></li><li class="sidebar-sub-header"><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#copying-into-encrypted-locations" class="sidebar-link">Copying into encrypted locations</a></li></ul></li><li><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#rename-and-trash-considerations" class="sidebar-link">Rename and Trash considerations</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#attack-vectors" class="sidebar-link">Attack vectors</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#hardware-access-exploits" class="sidebar-link">Hardware access exploits</a></li><li class="sidebar-sub-header"><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#root-access-exploits" class="sidebar-link">Root access exploits</a></li><li class="sidebar-sub-header"><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#hdfs-admin-exploits" class="sidebar-link">HDFS admin exploits</a></li><li class="sidebar-sub-header"><a href="/docs/hadoop-project-dist/hadoop-hdfs/TransparentEncryption.html#rogue-user-exploits" class="sidebar-link">Rogue user exploits</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="transparent-encryption-in-hdfs"><a href="#transparent-encryption-in-hdfs" class="header-anchor">#</a> Transparent Encryption in HDFS</h1> <h2 id="overview"><a href="#overview" class="header-anchor">#</a> Overview</h2> <p>HDFS implements transparent, end-to-end encryption. Once configured, data read from and written to special HDFS directories is transparently encrypted and decrypted without requiring changes to user application code. This encryption is also end-to-end, which means the data can only be encrypted and decrypted by the client. HDFS never stores or has access to unencrypted data or unencrypted data encryption keys. This satisfies two typical requirements for encryption: at-rest encryption (meaning data on persistent media, such as a disk) as well as in-transit encryption (e.g. when data is travelling over the network).</p> <h2 id="background"><a href="#background" class="header-anchor">#</a> Background</h2> <p>Encryption can be done at different layers in a traditional data management software/hardware stack. Choosing to encrypt at a given layer comes with different advantages and disadvantages.</p> <ul><li><p>Application-level encryption. This is the most secure and most flexible approach. The application has ultimate control over what is encrypted and can precisely reflect the requirements of the user. However, writing applications to do this is hard. This is also not an option for customers of existing applications that do not support encryption.</p></li> <li><p>Database-level encryption. Similar to application-level encryption in terms of its properties. Most database vendors offer some form of encryption. However, there can be performance issues. One example is that indexes cannot be encrypted.</p></li> <li><p>Filesystem-level encryption. This option offers high performance, application transparency, and is typically easy to deploy. However, it is unable to model some application-level policies. For instance, multi-tenant applications might want to encrypt based on the end user. A database might want different encryption settings for each column stored within a single file.</p></li> <li><p>Disk-level encryption. Easy to deploy and high performance, but also quite inflexible. Only really protects against physical theft.</p></li></ul> <p>HDFS-level encryption fits between database-level and filesystem-level encryption in this stack. This has a lot of positive effects. HDFS encryption is able to provide good performance and existing Hadoop applications are able to run transparently on encrypted data. HDFS also has more context than traditional filesystems when it comes to making policy decisions.</p> <p>HDFS-level encryption also prevents attacks at the filesystem-level and below (so-called “OS-level attacks”). The operating system and disk only interact with encrypted bytes, since the data is already encrypted by HDFS.</p> <h2 id="use-cases"><a href="#use-cases" class="header-anchor">#</a> Use Cases</h2> <p>Data encryption is required by a number of different government, financial, and regulatory entities. For example, the health-care industry has HIPAA regulations, the card payment industry has PCI DSS regulations, and the US government has FISMA regulations. Having transparent encryption built into HDFS makes it easier for organizations to comply with these regulations.</p> <p>Encryption can also be performed at the application-level, but by integrating it into HDFS, existing applications can operate on encrypted data without changes. This integrated architecture implies stronger encrypted file semantics and better coordination with other HDFS functions.</p> <h2 id="architecture"><a href="#architecture" class="header-anchor">#</a> Architecture</h2> <h3 id="overview-2"><a href="#overview-2" class="header-anchor">#</a> Overview</h3> <p>For transparent encryption, we introduce a new abstraction to HDFS: the encryption zone. An encryption zone is a special directory whose contents will be transparently encrypted upon write and transparently decrypted upon read. Each encryption zone is associated with a single encryption zone key which is specified when the zone is created. Each file within an encryption zone has its own unique data encryption key (DEK). DEKs are never handled directly by HDFS. Instead, HDFS only ever handles an encrypted data encryption key (EDEK). Clients decrypt an EDEK, and then use the subsequent DEK to read and write data. HDFS datanodes simply see a stream of encrypted bytes.</p> <p>A very important use case of encryption is to “switch it on” and ensure all files across the entire filesystem are encrypted. To support this strong guarantee without losing the flexibility of using different encryption zone keys in different parts of the filesystem, HDFS allows nested encryption zones. After an encryption zone is created (e.g. on the root directory /), a user can create more encryption zones on its descendant directories (e.g. /home/alice) with different keys. The EDEK of a file will generated using the encryption zone key from the closest ancestor encryption zone.</p> <p>A new cluster service is required to manage encryption keys: the Hadoop Key Management Server (KMS). In the context of HDFS encryption, the KMS performs three basic responsibilities:</p> <ol><li><p>Providing access to stored encryption zone keys</p></li> <li><p>Generating new encrypted data encryption keys for storage on the NameNode</p></li> <li><p>Decrypting encrypted data encryption keys for use by HDFS clients</p></li></ol> <p>The KMS will be described in more detail below.</p> <h3 id="accessing-data-within-an-encryption-zone"><a href="#accessing-data-within-an-encryption-zone" class="header-anchor">#</a> Accessing data within an encryption zone</h3> <p>When creating a new file in an encryption zone, the NameNode asks the KMS to generate a new EDEK encrypted with the encryption zone’s key. The EDEK is then stored persistently as part of the file’s metadata on the NameNode.</p> <p>When reading a file within an encryption zone, the NameNode provides the client with the file’s EDEK and the encryption zone key version used to encrypt the EDEK. The client then asks the KMS to decrypt the EDEK, which involves checking that the client has permission to access the encryption zone key version. Assuming that is successful, the client uses the DEK to decrypt the file’s contents.</p> <p>All of the above steps for the read and write path happen automatically through interactions between the DFSClient, the NameNode, and the KMS.</p> <p>Access to encrypted file data and metadata is controlled by normal HDFS filesystem permissions. This means that if HDFS is compromised (for example, by gaining unauthorized access to an HDFS superuser account), a malicious user only gains access to ciphertext and encrypted keys. However, since access to encryption zone keys is controlled by a separate set of permissions on the KMS and key store, this does not pose a security threat.</p> <h3 id="key-management-server-keyprovider-edeks"><a href="#key-management-server-keyprovider-edeks" class="header-anchor">#</a> Key Management Server, KeyProvider, EDEKs</h3> <p>The KMS is a proxy that interfaces with a backing key store on behalf of HDFS daemons and clients. Both the backing key store and the KMS implement the Hadoop KeyProvider API. See the <a href="/docs/hadoop-kms/index.html">KMS documentation</a> for more information.</p> <p>In the KeyProvider API, each encryption key has a unique key name. Because keys can be rolled, a key can have multiple key versions, where each key version has its own key material (the actual secret bytes used during encryption and decryption). An encryption key can be fetched by either its key name, returning the latest version of the key, or by a specific key version.</p> <p>The KMS implements additional functionality which enables creation and decryption of encrypted encryption keys (EEKs). Creation and decryption of EEKs happens entirely on the KMS. Importantly, the client requesting creation or decryption of an EEK never handles the EEK’s encryption key. To create a new EEK, the KMS generates a new random key, encrypts it with the specified key, and returns the EEK to the client. To decrypt an EEK, the KMS checks that the user has access to the encryption key, uses it to decrypt the EEK, and returns the decrypted encryption key.</p> <p>In the context of HDFS encryption, EEKs are encrypted data encryption keys (EDEKs), where a data encryption key (DEK) is what is used to encrypt and decrypt file data. Typically, the key store is configured to only allow end users access to the keys used to encrypt DEKs. This means that EDEKs can be safely stored and handled by HDFS, since the HDFS user will not have access to unencrypted encryption keys.</p> <h2 id="configuration"><a href="#configuration" class="header-anchor">#</a> Configuration</h2> <p>A necessary prerequisite is an instance of the KMS, as well as a backing key store for the KMS. See the <a href="/docs/hadoop-kms/index.html">KMS documentation</a> for more information.</p> <p>Once a KMS has been set up and the NameNode and HDFS clients have been correctly configured, an admin can use the hadoop key and hdfs crypto command-line tools to create encryption keys and set up new encryption zones. Existing data can be encrypted by copying it into the new encryption zones using tools like distcp.</p> <h3 id="configuring-the-cluster-keyprovider"><a href="#configuring-the-cluster-keyprovider" class="header-anchor">#</a> Configuring the cluster KeyProvider</h3> <h4 id="hadoop-security-key-provider-path"><a href="#hadoop-security-key-provider-path" class="header-anchor">#</a> hadoop.security.key.provider.path</h4> <p>The KeyProvider to use when interacting with encryption keys used when reading and writing to an encryption zone. HDFS clients will use the provider path returned from Namenode via getServerDefaults. If namenode doesn’t support returning key provider uri then client’s conf will be used.</p> <h3 id="selecting-an-encryption-algorithm-and-codec"><a href="#selecting-an-encryption-algorithm-and-codec" class="header-anchor">#</a> Selecting an encryption algorithm and codec</h3> <h4 id="hadoop-security-crypto-codec-classes-exampleciphersuite"><a href="#hadoop-security-crypto-codec-classes-exampleciphersuite" class="header-anchor">#</a> hadoop.security.crypto.codec.classes.EXAMPLECIPHERSUITE</h4> <p>The prefix for a given crypto codec, contains a comma-separated list of implementation classes for a given crypto codec (eg EXAMPLECIPHERSUITE). The first implementation will be used if available, others are fallbacks.</p> <h4 id="hadoop-security-crypto-codec-classes-aes-ctr-nopadding"><a href="#hadoop-security-crypto-codec-classes-aes-ctr-nopadding" class="header-anchor">#</a> hadoop.security.crypto.codec.classes.aes.ctr.nopadding</h4> <p>Default: org.apache.hadoop.crypto.OpensslAesCtrCryptoCodec, org.apache.hadoop.crypto.JceAesCtrCryptoCodec</p> <p>Comma-separated list of crypto codec implementations for AES/CTR/NoPadding. The first implementation will be used if available, others are fallbacks.</p> <h4 id="hadoop-security-crypto-cipher-suite"><a href="#hadoop-security-crypto-cipher-suite" class="header-anchor">#</a> hadoop.security.crypto.cipher.suite</h4> <p>Default: AES/CTR/NoPadding</p> <p>Cipher suite for crypto codec.</p> <h4 id="hadoop-security-crypto-jce-provider"><a href="#hadoop-security-crypto-jce-provider" class="header-anchor">#</a> hadoop.security.crypto.jce.provider</h4> <p>Default: None</p> <p>The JCE provider name used in CryptoCodec.</p> <h4 id="hadoop-security-crypto-buffer-size"><a href="#hadoop-security-crypto-buffer-size" class="header-anchor">#</a> hadoop.security.crypto.buffer.size</h4> <p>Default: 8192</p> <p>The buffer size used by CryptoInputStream and CryptoOutputStream.</p> <h3 id="namenode-configuration"><a href="#namenode-configuration" class="header-anchor">#</a> Namenode configuration</h3> <h4 id="dfs-namenode-list-encryption-zones-num-responses"><a href="#dfs-namenode-list-encryption-zones-num-responses" class="header-anchor">#</a> dfs.namenode.list.encryption.zones.num.responses</h4> <p>Default: 100</p> <p>When listing encryption zones, the maximum number of zones that will be returned in a batch. Fetching the list incrementally in batches improves namenode performance.</p> <h2 id="crypto-command-line-interface"><a href="#crypto-command-line-interface" class="header-anchor">#</a> crypto command-line interface</h2> <h3 id="createzone"><a href="#createzone" class="header-anchor">#</a> createZone</h3> <p>Usage: [-createZone -keyName <keyName> -path <path>]</path></keyName></p> <p>Create a new encryption zone.</p> <table><thead><tr><th></th></tr></thead> <tbody><tr><td>path</td></tr> <tr><td>keyName</td></tr></tbody></table> <h3 id="listzones"><a href="#listzones" class="header-anchor">#</a> listZones</h3> <p>Usage: [-listZones]</p> <p>List all encryption zones. Requires superuser permissions.</p> <h3 id="provisiontrash"><a href="#provisiontrash" class="header-anchor">#</a> provisionTrash</h3> <p>Usage: [-provisionTrash -path <path>]</path></p> <p>Provision a trash directory for an encryption zone.</p> <table><thead><tr><th></th></tr></thead> <tbody><tr><td>path</td></tr></tbody></table> <h3 id="getfileencryptioninfo"><a href="#getfileencryptioninfo" class="header-anchor">#</a> getFileEncryptionInfo</h3> <p>Usage: [-getFileEncryptionInfo -path <path>]</path></p> <p>Get encryption information from a file. This can be used to find out whether a file is being encrypted, and the key name / key version used to encrypt it.</p> <table><thead><tr><th></th></tr></thead> <tbody><tr><td>path</td></tr></tbody></table> <h3 id="reencryptzone"><a href="#reencryptzone" class="header-anchor">#</a> reencryptZone</h3> <p>Usage: [-reencryptZone <action> -path <zone>]</zone></action></p> <p>Re-encrypts an encryption zone, by iterating through the encryption zone, and calling the KeyProvider’s reencryptEncryptedKeys interface to batch-re-encrypt all files’ EDEKs with the latest version encryption zone key in the key provider. Requires superuser permissions.</p> <p>Note that re-encryption does not apply to snapshots, due to snapshots’ immutable nature.</p> <table><thead><tr><th></th></tr></thead> <tbody><tr><td>action</td></tr> <tr><td>path</td></tr></tbody></table> <p>Re-encryption is a NameNode-only operation in HDFS, so could potentially put intensive load to the NameNode. The following configurations can be changed to control the stress on the NameNode, depending on the acceptable throughput impact to the cluster.</p> <table><thead><tr><th></th></tr></thead> <tbody><tr><td>dfs.namenode.reencrypt.batch.size</td></tr> <tr><td>dfs.namenode.reencrypt.throttle.limit.handler.ratio</td></tr> <tr><td>dfs.namenode.reencrypt.throttle.limit.updater.ratio</td></tr></tbody></table> <h3 id="listreencryptionstatus"><a href="#listreencryptionstatus" class="header-anchor">#</a> listReencryptionStatus</h3> <p>Usage: [-listReencryptionStatus]</p> <p>List re-encryption information for all encryption zones. Requires superuser permissions.</p> <h2 id="example-usage"><a href="#example-usage" class="header-anchor">#</a> Example usage</h2> <p>These instructions assume that you are running as the normal user or HDFS superuser as is appropriate. Use sudo as needed for your environment.</p> <pre><code># As the normal user, create a new encryption key
hadoop key create mykey

# As the super user, create a new empty directory and make it an encryption zone
hadoop fs -mkdir /zone
hdfs crypto -createZone -keyName mykey -path /zone

# chown it to the normal user
hadoop fs -chown myuser:myuser /zone

# As the normal user, put a file in, read it out
hadoop fs -put helloWorld /zone
hadoop fs -cat /zone/helloWorld

# As the normal user, get encryption information from the file
hdfs crypto -getFileEncryptionInfo -path /zone/helloWorld
# console output: {cipherSuite: {name: AES/CTR/NoPadding, algorithmBlockSize: 16}, cryptoProtocolVersion: CryptoProtocolVersion{description='Encryption zones', version=1, unknownValue=null}, edek: 2010d301afbd43b58f10737ce4e93b39, iv: ade2293db2bab1a2e337f91361304cb3, keyName: mykey, ezKeyVersionName: mykey@0}
</code></pre> <h2 id="distcp-considerations"><a href="#distcp-considerations" class="header-anchor">#</a> Distcp considerations</h2> <h3 id="running-as-the-superuser"><a href="#running-as-the-superuser" class="header-anchor">#</a> Running as the superuser</h3> <p>One common usecase for distcp is to replicate data between clusters for backup and disaster recovery purposes. This is typically performed by the cluster administrator, who is an HDFS superuser.</p> <p>To enable this same workflow when using HDFS encryption, we introduced a new virtual path prefix, /.reserved/raw/, that gives superusers direct access to the underlying block data in the filesystem. This allows superusers to distcp data without needing having access to encryption keys, and also avoids the overhead of decrypting and re-encrypting data. It also means the source and destination data will be byte-for-byte identical, which would not be true if the data was being re-encrypted with a new EDEK.</p> <p>When using /.reserved/raw to distcp encrypted data, it’s important to preserve extended attributes with the <a href="/docs/hadoop-distcp/DistCp.html#Command_Line_Options">-px</a> flag. This is because encrypted file attributes (such as the EDEK) are exposed through extended attributes within /.reserved/raw, and must be preserved to be able to decrypt the file. This means that if the distcp is initiated at or above the encryption zone root, it will automatically create an encryption zone at the destination if it does not already exist. However, it’s still recommended that the admin first create identical encryption zones on the destination cluster to avoid any potential mishaps.</p> <h3 id="copying-into-encrypted-locations"><a href="#copying-into-encrypted-locations" class="header-anchor">#</a> Copying into encrypted locations</h3> <p>By default, distcp compares checksums provided by the filesystem to verify that the data was successfully copied to the destination. When copying from unencrypted or encrypted location into an encrypted location, the filesystem checksums will not match since the underlying block data is different because a new EDEK will be used to encrypt at destination. In this case, specify the <a href="/docs/hadoop-distcp/DistCp.html#Command_Line_Options">-skipcrccheck</a> and <a href="/docs/hadoop-distcp/DistCp.html#Command_Line_Options">-update</a> distcp flags to avoid verifying checksums.</p> <h2 id="rename-and-trash-considerations"><a href="#rename-and-trash-considerations" class="header-anchor">#</a> Rename and Trash considerations</h2> <p>HDFS restricts file and directory renames across encryption zone boundaries. This includes renaming an encrypted file / directory into an unencrypted directory (e.g., hdfs dfs mv /zone/encryptedFile /home/bob), renaming an unencrypted file or directory into an encryption zone (e.g., hdfs dfs mv /home/bob/unEncryptedFile /zone), and renaming between two different encryption zones (e.g., hdfs dfs mv /home/alice/zone1/foo /home/alice/zone2). In these examples, /zone, /home/alice/zone1, and /home/alice/zone2 are encryption zones, while /home/bob is not. A rename is only allowed if the source and destination paths are in the same encryption zone, or both paths are unencrypted (not in any encryption zone).</p> <p>This restriction enhances security and eases system management significantly. All file EDEKs under an encryption zone are encrypted with the encryption zone key. Therefore, if the encryption zone key is compromised, it is important to identify all vulnerable files and re-encrypt them. This is fundamentally difficult if a file initially created in an encryption zone can be renamed to an arbitrary location in the filesystem.</p> <p>To comply with the above rule, each encryption zone has its own .Trash directory under the “zone directory”. E.g., after hdfs dfs rm /zone/encryptedFile, encryptedFile will be moved to /zone/.Trash, instead of the .Trash directory under the user’s home directory. When the entire encryption zone is deleted, the “zone directory” will be moved to the .Trash directory under the user’s home directory.</p> <p>If the encryption zone is the root directory (e.g., / directory), the trash path of root directory is /.Trash, not the .Trash directory under the user’s home directory, and the behavior of renaming sub-directories or sub-files in root directory will keep consistent with the behavior in a general encryption zone, such as /zone which is mentioned at the top of this section.</p> <p>The crypto command before Hadoop 2.8.0 does not provision the .Trash directory automatically. If an encryption zone is created before Hadoop 2.8.0, and then the cluster is upgraded to Hadoop 2.8.0 or above, the trash directory can be provisioned using -provisionTrash option (e.g., hdfs crypto -provisionTrash -path /zone).</p> <h2 id="attack-vectors"><a href="#attack-vectors" class="header-anchor">#</a> Attack vectors</h2> <h3 id="hardware-access-exploits"><a href="#hardware-access-exploits" class="header-anchor">#</a> Hardware access exploits</h3> <p>These exploits assume that attacker has gained physical access to hard drives from cluster machines, i.e. datanodes and namenodes.</p> <ol><li>Access to swap files of processes containing data encryption keys.</li></ol> <pre><code>* By itself, this does not expose cleartext, as it also requires access to encrypted block files.

* This can be mitigated by disabling swap, using encrypted swap, or using mlock to prevent keys from being swapped out.
</code></pre> <ol start="2"><li>Access to encrypted block files.</li></ol> <pre><code>* By itself, this does not expose cleartext, as it also requires access to DEKs.
</code></pre> <h3 id="root-access-exploits"><a href="#root-access-exploits" class="header-anchor">#</a> Root access exploits</h3> <p>These exploits assume that attacker has gained root shell access to cluster machines, i.e. datanodes and namenodes. Many of these exploits cannot be addressed in HDFS, since a malicious root user has access to the in-memory state of processes holding encryption keys and cleartext. For these exploits, the only mitigation technique is carefully restricting and monitoring root shell access.</p> <ol><li>Access to encrypted block files.</li></ol> <pre><code>* By itself, this does not expose cleartext, as it also requires access to encryption keys.
</code></pre> <ol start="2"><li>Dump memory of client processes to obtain DEKs, delegation tokens, cleartext.</li></ol> <pre><code>* No mitigation.
</code></pre> <ol start="3"><li>Recording network traffic to sniff encryption keys and encrypted data in transit.</li></ol> <pre><code>* By itself, insufficient to read cleartext without the EDEK encryption key.
</code></pre> <ol start="4"><li>Dump memory of datanode process to obtain encrypted block data.</li></ol> <pre><code>* By itself, insufficient to read cleartext without the DEK.
</code></pre> <ol start="5"><li>Dump memory of namenode process to obtain encrypted data encryption keys.</li></ol> <pre><code>* By itself, insufficient to read cleartext without the EDEK’s encryption key and encrypted block files.
</code></pre> <h3 id="hdfs-admin-exploits"><a href="#hdfs-admin-exploits" class="header-anchor">#</a> HDFS admin exploits</h3> <p>These exploits assume that the attacker has compromised HDFS, but does not have root or hdfs user shell access.</p> <ol><li>Access to encrypted block files.</li></ol> <pre><code>* By itself, insufficient to read cleartext without the EDEK and EDEK encryption key.
</code></pre> <ol start="2"><li>Access to encryption zone and encrypted file metadata (including encrypted data encryption keys), via -fetchImage.</li></ol> <pre><code>* By itself, insufficient to read cleartext without EDEK encryption keys.
</code></pre> <h3 id="rogue-user-exploits"><a href="#rogue-user-exploits" class="header-anchor">#</a> Rogue user exploits</h3> <p>A rogue user can collect keys of files they have access to, and use them later to decrypt the encrypted data of those files. As the user had access to those files, they already had access to the file contents. This can be mitigated through periodic key rolling policies. The reencryptZone command is usually required after key rolling, to make sure the EDEKs on existing files use the new version key.</p> <p>Manual steps to a complete key rolling and re-encryption are listed below. These instructions assume that you are running as the key admin or HDFS superuser as is appropriate.</p> <pre><code># As the key admin, roll the key to a new version
hadoop key roll exposedKey

# As the super user, re-encrypt the encryption zone. Possibly list zones first.
hdfs crypto -listZones
hdfs crypto -reencryptZone -start -path /zone

# As the super user, periodically check the status of re-encryption
hdfs crypto -listReencryptionStatus

# As the super user, get encryption information from the file and double check it's encryption key version
hdfs crypto -getFileEncryptionInfo -path /zone/helloWorld
# console output: {cipherSuite: {name: AES/CTR/NoPadding, algorithmBlockSize: 16}, cryptoProtocolVersion: CryptoProtocolVersion{description='Encryption zones', version=2, unknownValue=null}, edek: 2010d301afbd43b58f10737ce4e93b39, iv: ade2293db2bab1a2e337f91361304cb3, keyName: exposedKey, ezKeyVersionName: exposedKey@1}
</code></pre></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.44e5c4e8.js" defer></script><script src="/assets/js/2.fd33e103.js" defer></script><script src="/assets/js/82.1f34b986.js" defer></script>
  </body>
</html>
